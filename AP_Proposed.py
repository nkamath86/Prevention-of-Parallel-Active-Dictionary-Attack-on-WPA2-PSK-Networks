# version 1.0
# Access Point - Proposed System
from passlib.hash import pbkdf2_sha512
import hmac, hashlib, pyDes, binascii
from random import randint

# to generate hash
# hash = pbkdf2_sha512.hash("sometext") 
# hash = pbkdf2_sha512.using(salt = "in_bytes_max_1024", salt_size = int, rounds = int, relaxed = bool).hash("some_stuff")
# to check hashes
# pbkdf2_sha512.verify("",hash) # returns boolean

# taking inputs
# ssid = raw_input("SSID: ")
# passphrase = raw_input("Passphrase: ")
# ap_mac = raw_input("AP MAC: ").decode('hex')	# binary conv
# s_mac = raw_input("Client MAC: ").decode('hex')	# bianry conv
# ap_mac = binascii.a2b_hex(raw_input("AP MAC: "))

print ''
# sample inputs for testing purposes only
ssid = 'WIFINAME'
passphrase = 'Password'
ap_mac = 'fafafafa'.decode('hex')
s_mac = 'fafafafa'.decode('hex')

# Global Counter
# gc = [format(0, '#010b'), format(0, '#010b')]
gc = [bin(randint(0,65535)),bin(0)]   # randomly generated value for first 16 bits 
# gc[1] = bin(int(gc[1],2)+1)       # and a 0 for next 16 bits
# print gc

def inc(gc):    # func to increment gc
    gc[1] = bin(int(gc[1],2)+1) 
    temp = gc[0]
    if len(gc[1]) == 19:	# reset after filling 16 bits
        gc[1] = bin(0)
        gc[0] = bin(randint(0,65535)) 
        while temp == gc[0]:
            gc[0] = bin(randint(0,65535))
    return gc

# for _ in xrange(257):
# 	print gc
# 	gc = inc(gc)

# Key Generation
# PSK - 512 bits 
print 'PSK: ' 
PSK = pbkdf2_sha512.using(salt = ssid, salt_size = len(ssid), rounds = 4096).hash(passphrase)
PSK = str(PSK.split('$')[4]).replace('.','+')+'=='
PSK = PSK.decode('base64').encode('hex')
# print PSK, len(PSK)
print PSK
print 'Length of PSK (bits): ' + str(int(len(PSK))*4) + '\n'


# PMK 
print 'PMK: '
PMK = pbkdf2_sha512.using(salt = ssid, salt_size = len(ssid), rounds = 4096).hash(PSK)
PMK = str(PMK.split('$')[4]).replace('.','+')+'=='
PMK = PMK.decode('base64').encode('hex')
# print PMK, len(PMK)
print PMK
print 'Length of PMK (bits): ' + str(int(len(PMK))*4) + '\n'

# PTK
key_data = min(ap_mac,s_mac) + max(ap_mac,s_mac) + gc[0] + gc[1]
gc = inc(gc)
key_data += gc[0] + gc[1]
pke = "Pairwise key expansion"  

def PRF383(key,A,B):  # function for PRF383
    blen = 48	# 384 bits # number of bytes = 48
    i    = 0
    R    = ''
    while i <= ((blen*8+159)/160):
        hmacsha512 = hmac.new(key, A+chr(0x00)+B+chr(i), hashlib.sha512)
        i += 1
        R += hmacsha512.digest()
    return R[:blen]

PTK = PRF383(PMK, pke, key_data).encode('hex')	# hex string of 96 

# Other Keys
KCK = PTK[:32]
KEK = PTK[32:64]
TK = PTK[64:]

print 'PTK: ' + '\n' + PTK
print 'Length of PTK (bits): ' + str(len(PTK)*4) + '\n'
print 'KCK: ' + '\n' + KCK
print 'Length of KCK (bits): ' + str(len(KCK)*4) + '\n'
print 'KEK: ' + '\n' + KEK
print 'Length of KEK (bits): ' + str(len(KEK)*4) + '\n'
print 'TK: ' + '\n' + TK
print 'Length of TK (bits): ' + str(len(TK)*4) + '\n'

# Encrypting gc with first 24 bytes of PMK
# key =  bin(int(PMK[:6],16))[2:]	# first 24 Bytes of PMK
# print "key: " + str(key)
# print 'gc: ' + gc[0][2:] + gc[1][2:]
# print bin(int(PMK,16))[2:]
# print ''+gc[0]+gc[1]
# cipher = pyDes.triple_des(key).encrypt('' + gc[0] + gc[1], padmode = 2)	
# decipher = pyDes.triple_des(key).decrypt(cipher)
# print len(bin(int(PMK[:6],16))[2:])
def enc(PMK, gc):   # function to encrypt gc
    key =  bin(int(PMK[:4],16))[2:] # first 24 Bytes of PMK
    cipher = pyDes.triple_des(key).encrypt('' + gc[0] + gc[1], padmode = 2)
    return cipher

# cipher = enc(PMK,gc)
# print 'Encrypted Global Counter: ' + cipher # encypted gc
# print 'Encrypted Global Counter in hex: '
# w = [cipher]
# print w
# print ''

# print decipher

# Calculating MIC
# MIC should use hmacsh512 with key as KCK and data as EAPoL header
EAPoL_header = "Insert Valid EAPoL header data here".encode('hex')
# print EAPoL_header
MIC = hmac.new(KCK, EAPoL_header, hashlib.sha512).digest()

# Message Generation

# Message 1
message1 = enc(PMK, gc)   # encrypted gc is sent via message1 by ap
gc = inc(gc)

# Message 2
# message2 = MIC + str(enc(PMK, gc))    # MIC & encrypted incremented gc in message2 by client
# gc = inc(gc)

# Message 3
# here gc will be extracted from message 2 and then incremented
# but for the sake of convenience we will increment here twice
gc = inc(gc)    # to be used only until handshaking is not done
Install_PTK = 'True'  # Flag is set if Client is authenticated
GTK = bin(randint(0,2**127))[2:]    # GTK generated by ap
key1 = bin(int(KEK[:6],16))[2:]  # KEK used to encrypt GTK
# print 'kek: '
# print key
# print KEK
eGTK = pyDes.triple_des(key1).encrypt(GTK, padmode = 2)  # encrypt GTK with KEK
message3 = Install_PTK + MIC + eGTK + enc(PMK, gc) # message3 sent by ap
gc = inc(gc)

# Message 4
# message4 = MIC + enc(PMK, gc)    # message4 sent by client
# gc = inc(gc)   
# again the gc is extracted and used
# but for the sake of convenience we will still be incrementing it
gc = inc(gc)    # only to be used until handshaking is not done

# End of handshake
# Output messages
print 'message1: '
print [message1]
print ''

# print 'message2: '
# print [message2]
# print ''

print 'message3: '
print [message3]
print ''

# print 'message4: '
# print [message4]
# print ''


