import socket
import PyLorcon2
import sys
from random import randint
from passlib.hash import pbkdf2_sha512
import hmac, hashlib, pyDes

gc = [bin(randint(0,65535)),bin(0)]   # randomly generated value for first 16 bits 

# predefined values
ssid = 'WIFINAME'
passphrase = 'Password'
destination_addr = '\x50\xb7\xc3\xe5\x7d\x09'	# Client MAC 
source_addr = '\x70\x1a\x04\xe8\xe1\x7c'	# AP MAC

# func to increment gc
def inc(gc):    
    gc[1] = bin(int(gc[1],2)+1) 
    temp = gc[0]
    if len(gc[1]) == 19:	# reset after filling 16 bits
        gc[1] = bin(0)
        gc[0] = bin(randint(0,65535)) 
        while temp == gc[0]:
            gc[0] = bin(randint(0,65535))
    return gc

# function to encrypt gc
def enc(PMK, gc):   
    key =  bin(int(PMK[:4],16))[2:] # first 24 Bytes of PMK
    cipher = pyDes.triple_des(key).encrypt(gc, padmode = 2)
    return cipher

# function to decrypt gc
def dec(PMK, gc):   
    key = bin(int(PMK[:4],16))[2:] # first 24 Bytes of PMK
    cipher = pyDes.triple_des(key).decrypt(gc, padmode = 2)
    return cipher


# -------------------------------------------------------------------- #
# Key Generation
# PSK - 512 bits 
print 'PSK: ' 
PSK = pbkdf2_sha512.using(salt = ssid, salt_size = len(ssid), rounds = 4096).hash(passphrase)
PSK = str(PSK.split('$')[4]).replace('.','+')+'=='
PSK = PSK.decode('base64').encode('hex')
# print PSK, len(PSK)
print PSK
print 'Length of PSK (bits): ' + str(int(len(PSK))*4) + '\n'


# PMK 
print 'PMK: '
PMK = pbkdf2_sha512.using(salt = ssid, salt_size = len(ssid), rounds = 4096).hash(PSK)
PMK = str(PMK.split('$')[4]).replace('.','+')+'=='
PMK = PMK.decode('base64').encode('hex')
# print PMK, len(PMK)
print PMK
print 'Length of PMK (bits): ' + str(int(len(PMK))*4) + '\n'

# PTK
key_data = min(destination_addr,source_addr) + max(destination_addr,source_addr) + str(gc[0]) + str(gc[1])
gc = inc(gc)
key_data += str(gc[0]) + str(gc[1])
# print key_data.encode('hex')
# print gc[0]
# print gc[1]
pke = "Pairwise key expansion"  

def PRF383(key,A,B):  # function for PRF383
    blen = 48	# 384 bits # number of bytes = 48
    i    = 0
    R    = ''
    while i <= ((blen*8+159)/160):
        hmacsha512 = hmac.new(key, A+chr(0x00)+B+chr(i), hashlib.sha512)
        i += 1
        R += hmacsha512.digest()
    return R[:blen]

PTK = PRF383(PMK, pke, key_data).encode('hex')	# hex string of 96 


# Other Keys
KCK = PTK[:32]
KEK = PTK[32:64]
TK = PTK[64:]

print 'PTK: ' + '\n' + PTK
print 'Length of PTK (bits): ' + str(len(PTK)*4) + '\n'
print 'KCK: ' + '\n' + KCK
print 'Length of KCK (bits): ' + str(len(KCK)*4) + '\n'
print 'KEK: ' + '\n' + KEK
print 'Length of KEK (bits): ' + str(len(KEK)*4) + '\n'
print 'TK: ' + '\n' + TK
print 'Length of TK (bits): ' + str(len(TK)*4) + '\n'

# --------------------------------------------------------------- #
# connection stuff
# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the port
server_address = ('192.168.43.40', 6677)
print >>sys.stderr, 'starting up on %s port %s' % server_address
sock.bind(server_address)
sock.listen(1)	# wait for client to associate/connect
connection, client_address = sock.accept()	# accept client conn

# --------------------------------------------------------------- #
# message 1 consists of encrypted gc 
# print gc[0]
# print gc[1]
# eGC = []
# eGC.append(enc(PMK, gc[0]))
# eGC.append(enc(PMK, gc[1]))
# print data.encode('hex')
# connection.sendall(gc[0] + '/' + gc[1])
eGC = enc(PMK, gc[0]+gc[1])
print eGC
print dec(PMK, eGC)
connection.sendall(eGC)
gc = inc(gc)
# print 'PTK: again : '
# connection.sendall(PTK)
# print PTK
# --------------------------------------------------------------- #
# message 2 contains GC+1 and MIC
data = connection.recv(1024)
data = data.encode('hex').split('000000')[1]# MIC only
print 'MIC: ' + data.encode('hex')
#---------------------------------------------------------------- #
# message 3 or 4
EAPoL_header = ''
AP_MIC = hmac.new(KCK, EAPoL_header, hashlib.sha512).digest().encode('hex')
# print AP_MIC.encode('hex')
# print data
if AP_MIC == data:
	print 'passphrase is right'
	GTK = bin(randint(0,2**127))[2:]    # GTK generated by ap
	key1 = bin(int(KEK[:6],16))[2:]  # KEK used to encrypt GTK
	eGTK = pyDes.triple_des(key1).encrypt(GTK, padmode = 2)  # encrypt GTK with KEK
	gc = inc(gc)
	data = 'Passphrase Correct! '+ '/'
	data += enc(PMK,gc) + '/' + eGTK + '/' + AP_MIC
	connection.sendall(data)
else:
	connection.sendall('Wrong Passphrase. Deauthentication Initiated.')
# --------------------------------------------------------------- #
connection.close()

